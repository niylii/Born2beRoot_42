# Born2beRoot Monitoring Script - Complete Guide

## 1. **Shebang (`#!/bin/bash`)**

```bash
#!/bin/bash
```

**What it is**: The first line of your script.

**What it does**: Tells the system "hey, use bash to run this file"

**Why we need it**: Without it, the system doesn't know what interpreter to use. It's like saying "open this with Notepad" vs "open this with Photoshop"

---

## 2. **`uname -a` (Architecture & Kernel)**

```bash
uname -a
```

**What it does**: Prints system information

**Output example**: `Linux debian 5.10.0-8-amd64 #1 SMP Debian 5.10.46-4 (2021-08-03) x86_64 GNU/Linux`

**Breaking down the flags**:
- `uname` = Unix name (the command)
- `-a` = all information (architecture, kernel version, machine hardware, etc.)

**Try it**: Just type `uname -a` in your terminal right now!

---

## 3. **Physical CPUs**

```bash
grep "physical id" /proc/cpuinfo | sort -u | wc -l
```

**Let me break this DOWN**:

**`/proc/cpuinfo`**: A special file containing CPU information. Not a real file, it's generated by the kernel when you read it.

**`grep "physical id"`**: Searches for lines containing "physical id" 
- Each physical CPU has a unique physical id (0, 1, 2, etc.)

**`sort -u`**: Sorts the lines and removes duplicates (`-u` = unique)
- If you have 8 cores on 1 physical CPU, you'll see "physical id : 0" eight times
- `sort -u` makes it just one line

**`wc -l`**: Counts lines (`-l` = lines)
- So if you have 2 physical CPUs, you get "2"

**Try each step**:
```bash
cat /proc/cpuinfo | grep "physical id"          # See all physical id lines
cat /proc/cpuinfo | grep "physical id" | sort -u  # See unique ones
cat /proc/cpuinfo | grep "physical id" | sort -u | wc -l  # Count them
```

---

## 4. **Virtual CPUs (Cores/Threads)**

```bash
grep "processor" /proc/cpuinfo | wc -l
```

**Breaking it down**:

**`grep "processor"`**: Each CPU core/thread has a line that says "processor : 0", "processor : 1", etc.

**`wc -l`**: Count those lines = total virtual processors

**Why is this different from physical?**: 
- 1 physical CPU might have 4 cores = 4 virtual CPUs
- With hyperthreading, 4 cores might show as 8 virtual CPUs

---

## 5. **RAM Usage**

```bash
free -m
```

**What it shows**:
```
              total        used        free      shared  buff/cache   available
Mem:           7975        2845        3128         256        2001        4685
```

**Breaking down the flags**:
- `free` = show memory usage
- `-m` = show in megabytes (you can use `-g` for gigabytes, `-k` for kilobytes)

**The columns**:
- **total**: Total RAM installed
- **used**: RAM being used by programs
- **free**: RAM doing nothing
- **buff/cache**: RAM used for caching (can be freed if needed)
- **available**: How much RAM is truly available for new programs

**To calculate percentage**:
```bash
free | grep Mem | awk '{printf("%.2f%%"), $3/$2 * 100}'
```

Let me break THIS down:

**`free`**: Get memory info (without -m, it's in KB)

**`grep Mem`**: Get only the "Mem:" line

**`awk '{...}'`**: AWK is a text processing tool
- `$3` = third column (used memory)
- `$2` = second column (total memory)
- `$3/$2 * 100` = (used/total) × 100 = percentage
- `printf("%.2f%%")` = print with 2 decimal places and a % sign

**Better version with MB display**:
```bash
free -m | awk 'NR==2{printf "%s/%sMB (%.2f%%)", $3,$2,$3*100/$2}'
```

**`NR==2`**: Only process the 2nd row (the Mem: line)

---

## 6. **Disk Usage**

```bash
df -h
```

**What it does**: Shows disk filesystem usage

**Breaking down the flags**:
- `df` = disk free (shows disk space)
- `-h` = human readable (shows GB instead of bytes)

**Output example**:
```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        20G   10G   9G  53% /
```

**To get just the root partition info**:
```bash
df -h / | awk 'NR==2{printf "%s/%s (%s)", $3,$2,$5}'
```

**Breaking it down**:

**`df -h /`**: Show disk usage for root partition only

**`awk 'NR==2{...}'`**: Process only the 2nd row (the data line)

**`$3,$2,$5`**: Column 3 (used), column 2 (total), column 5 (percentage)

---

## 7. **CPU Usage Percentage**

```bash
top -bn1 | grep '^%Cpu' | awk '{printf("%.1f%%"), 100 - $8}'
```

**Breaking it down**:

**`top`**: Shows running processes and system stats

**`-b`**: Batch mode (run once and output, don't keep refreshing)

**`-n1`**: Run only 1 iteration

**`grep '^%Cpu'`**: Get the CPU line (looks like: `%Cpu(s):  5.2 us,  2.1 sy,  0.0 ni, 92.1 id...`)

**`awk '{printf("%.1f%%"), 100 - $8}'`**: 
- `$8` is the "idle" percentage
- `100 - idle` = usage percentage
- `%.1f%%` = format with 1 decimal place and % sign

---

## 8. **Last Reboot**

```bash
who -b
```

**Super simple!**

**`who`**: Shows who is logged in

**`-b`**: Show time of last system boot

**Output**: `system boot 2024-11-25 14:32`

**To get just the date and time**:
```bash
who -b | awk '{print $3, $4}'
```

**`$3, $4`**: Column 3 (date) and column 4 (time)

---

## 9. **LVM Active?**

```bash
lsblk | grep "lvm" | wc -l
```

**Breaking it down**:

**`lsblk`**: List block devices (your disks, partitions, etc.)

**`grep "lvm"`**: Find lines containing "lvm"

**`wc -l`**: Count them

**To make it say "yes" or "no"**:
```bash
if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then echo "yes"; else echo "no"; fi
```

**Breaking down the if statement**:

**`if [ condition ]; then ... else ... fi`**: Basic if-else structure in bash

**`$(lsblk | grep "lvm" | wc -l)`**: Run the command and use its output

**`-gt 0`**: Greater than 0 (if we found any lvm volumes)

**`echo "yes"`**: Print "yes"

**`else echo "no"`**: Otherwise print "no"

**`fi`**: End of if statement (if backwards!)

---

## 10. **Active Connections**

```bash
ss -t | grep ESTAB | wc -l
```

or

```bash
netstat -an | grep ESTABLISHED | wc -l
```

**Breaking it down**:

**`ss`**: Socket statistics (shows network connections) - modern replacement for netstat

**`-t`**: TCP connections only

**`grep ESTAB`**: Only established (active) connections

**`wc -l`**: Count them

**Note**: `ss` is preferred on modern systems, but `netstat` works too if `ss` isn't available.

---

## 11. **Number of Users**

```bash
users | wc -w
```

**Breaking it down**:

**`users`**: Lists usernames of logged-in users

**`wc -w`**: Count words (`-w` = words, not lines)

**Why words?**: `users` outputs like: `root john mary` (space-separated)

---

## 12. **IP Address**

```bash
hostname -I
```

**What it does**: Shows all IP addresses of your machine

**Breaking down the flags**:
- `hostname` = show/set system's hostname
- `-I` = show all IP addresses (capital i)

**To get just the first IP**:
```bash
hostname -I | awk '{print $1}'
```

**`awk '{print $1}'`**: Print the first word/column

---

## 13. **MAC Address**

```bash
ip link show | grep "link/ether" | awk '{print $2}'
```

**Breaking it down**:

**`ip link show`**: Shows network interfaces and their details

**`grep "link/ether"`**: Find the line with MAC address (Ethernet hardware address)

**`awk '{print $2}'`**: Print the second column (the actual MAC address)

**Output example**: `08:00:27:51:ac:6f`

---

## 14. **Sudo Commands Count**

```bash
journalctl _COMM=sudo | grep COMMAND | wc -l
```

or if you have a sudo log file:

```bash
cat /var/log/sudo/sudo.log | grep COMMAND | wc -l
```

**Breaking it down**:

**`journalctl`**: System journal/log viewer (systemd's logging system)

**`_COMM=sudo`**: Filter for sudo command entries

**`grep COMMAND`**: Find lines where actual commands were run

**`wc -l`**: Count them

**Note**: The log file location might vary. Some systems use `/var/log/sudo/sudo.log`, others might use journalctl.

---

## Setting Up the Script

### Step 1: Create the Script

```bash
sudo nano /usr/local/bin/monitoring.sh
```

Paste the complete script above, then save and exit (Ctrl+X, then Y, then Enter).

### Step 2: Make it Executable

```bash
sudo chmod +x /usr/local/bin/monitoring.sh
```

### Step 3: Test It

```bash
sudo /usr/local/bin/monitoring.sh
```

You should see the output broadcasted to all terminals!

---

## Scheduling with Cron (Run Every 10 Minutes)

### Step 1: Edit Root's Crontab

```bash
sudo crontab -e
```

### Step 2: Add This Line

```
*/10 * * * * /usr/local/bin/monitoring.sh
```

**What does `*/10 * * * *` mean?**

Cron uses 5 fields:
```
* * * * *
│ │ │ │ │
│ │ │ │ └─── Day of week (0-7, 0 and 7 are Sunday)
│ │ │ └───── Month (1-12)
│ │ └─────── Day of month (1-31)
│ └───────── Hour (0-23)
└─────────── Minute (0-59)
```

So `*/10 * * * *` means:
- `*/10` - Every 10 minutes
- `*` - Every hour
- `*` - Every day of month
- `*` - Every month
- `*` - Every day of week

**Result**: Runs every 10 minutes, 24/7

### Step 3: Save and Exit

The cron job is now active!

---

## Useful Cron Examples

```bash
# Every minute
* * * * * /path/to/script.sh

# Every hour at minute 30
30 * * * * /path/to/script.sh

# Every day at 2:30 AM
30 2 * * * /path/to/script.sh

# Every Monday at 9:00 AM
0 9 * * 1 /path/to/script.sh

# At server startup
@reboot /path/to/script.sh
```

---

## Troubleshooting

### Script doesn't run?

1. Check if it's executable:
```bash
ls -l /usr/local/bin/monitoring.sh
```
Should show `rwxr-xr-x` (x = executable)

2. Check cron logs:
```bash
sudo grep CRON /var/log/syslog
```

3. Run manually to see errors:
```bash
sudo /usr/local/bin/monitoring.sh
```

### Cron not working?

Check if cron service is running:
```bash
sudo systemctl status cron
```

Start it if needed:
```bash
sudo systemctl start cron
```

---

## Key Concepts to Remember

### Pipes (`|`)
Sends output of one command as input to another.
```bash
cat file.txt | grep "hello"
```

### AWK
Text processing tool that works on columns.
```bash
echo "hello world" | awk '{print $2}'  # Prints "world"
```

### Grep
Searches for patterns in text.
```bash
cat file.txt | grep "error"  # Shows lines containing "error"
```

### Command Substitution `$(...)`
Runs a command and uses its output.
```bash
echo "Today is $(date)"  # Runs date command, inserts output
```

### Wall
Broadcasts a message to all logged-in users' terminals.
```bash
wall "Server will reboot in 5 minutes!"
```
